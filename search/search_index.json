{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to RoboRambler Documentations!","text":"<p>Welcome to RoboRamblers!</p> <p>This is the technical documentation maintained for RoboRambler.</p> <p>To get started on our ROS-based Software Stack, check Getting Started. To get started on Embedded Development check Getting Started</p> <p>To find past issues and troubleshoot, check TroubleShooting.</p>"},{"location":"about/","title":"About","text":"<p>RoboRambler at Georgia Tech was founded in 2022 and has participated in two seasons in RMUL NA regional match. Currently, we developed a standard robot design featuring a swerve chassis and an effective turret, and we have built a fleet consisting of three robots to fight in 3v3 games.</p> <p>RoboRambler Documentations is created using MkDocs.</p>"},{"location":"trouble-shooting/","title":"Trouble Shooting","text":"<p>This pages contains some of the common problems and the known solutions to them.</p>"},{"location":"trouble-shooting/#communication","title":"Communication","text":"<p>Problem: incompatible CH340 driver of some types of models. Unable to establish connection, and the device does not show up under <code>\\dev</code>.</p> <p>Solution: run <code>sudo apt-get autoremove brltty</code>. <code>brytty</code> sometimes interfere the functionality of certain drivers for CH340.</p> <p>Problem: want to use multiple USB2CAN devices, but the naming for the device is not fixed.</p> <p>Solution: If you are using a Canable device, you can use the <code>slcan</code> related command. If you are using a device with CandleLight firmware, you should checkout this section of the Canable Documentation and see how you can set udev rules properly.</p> <p>All the socketcan devices should be under <code>/sys/class/net</code>. You can check the properties of the device using <code>sudo udevadm info -ap &lt;device_path&gt;</code>. udev file should be created at <code>/etc/udev/rules.d/99-candlelight.rules</code>.</p> <p>Considering writing udev so that it can be deteremined using solely <code>idVendor</code>, <code>idProduct</code>, <code>serial</code>. If not possible, use <code>KERNELS</code> property to assign name based on physical port locations of its parent usb device. Below is an example udev file.</p> <pre><code>SUBSYSTEM==\"net\", ATTRS{idProduct}==\"606f\", ATTRS{idVendor}==\"1d50\", ATTRS{serial}==\"004C00375646571520363132\", NAME=\"can_bytewrek_0\" # using serial number\nSUBSYSTEM==\"net\", KERNELS==\"3-1\", ATTRS{product}==\"XCAN-USB\", ATTRS{idProduct}==\"000c\", ATTRS{idVendor}==\"0c72\", NAME=\"can_xcan_0\" # using kernel\n</code></pre> <p>After creating udev file, run this command and unplug/replug to activate: <pre><code>sudo udevadm control --reload-rules &amp;&amp; sudo systemctl restart systemd-udevd &amp;&amp; sudo udevadm trigger\n</code></pre></p>"},{"location":"getting-started/embedded-installation/","title":"Embedded Development Environment Installation","text":""},{"location":"getting-started/embedded-installation/#stm32cubemx","title":"STM32CubeMX","text":"<p>The first tool you will need is the STM32CubeMX. You can download it here:</p> <p>STM32CubeMX - STMicroelectronics</p> <p>Download the suitable version for your system. We Use Version 6.6.1!</p> <p>After downloading just install it using the default options.</p> <p>CubeMX is used to set up the processor on board and copy default HAL libraries for our projects.</p>"},{"location":"getting-started/embedded-installation/#arm-compiler","title":"ARM Compiler","text":"<p>STM32 is an ARM-based processor. Thus normal compilers such as GCC on our system (usually x86) cannot compile code for it. We need cross-compilation to compile source code for ARM on an x86 machine. For this, we need the GNU ARM compiler. Another option is clang, but we will go with GNU for now.</p> <p>Download the GNU Arm toolchain here:</p> <p>Arm GNU Toolchain Downloads - Arm Developer</p> <p>Use the latest version for bare-metal targets (arm-none-eabi).</p> <p>After installation (take note of where it is installed). Test if the compiler is added to your PATH by:</p> <pre><code>arm-none-eabi-gcc -v\n</code></pre> <p>This should tell you your version of the ARM GNU GCC compiler. If an error pops up, make sure to add where you installed it to your system PATH. (Default is in /Applications/ARM/bin for Mac users)</p>"},{"location":"getting-started/embedded-installation/#clion","title":"CLion","text":"<p>We use CLion for development. Download it from JetBrains. After you have downloaded it, clone our template repo with the recursive option.</p> <p>Then open up the whole folder with CLion.</p> <p>A first-time opening of CLion would ask you to select the build tools. The default is file since we will specify our compiler in the CMake file later.</p> <p>After you open the project folder for the first time, CLion will ask you for the CMake build type specification. The default (debug) is fine. You can just continue to open the project and wait for CLion to configure things for you.</p> <p>After all the indexing and other auto-configurations by CLion are done, navigate to CMake on the bottom bar. A successful CMake configuration would look like this:</p> <p></p> <p>Next, you can try to compile the code with the hammer icon on the top right. If everything goes well, CLion will output something on the bottom area telling you that things have been compiled properly.</p> <p></p> <p>The .elf is the binary file compiled by our compiler. Next, I will show you how to download the firmware to our target board and debug with your code.</p>"},{"location":"getting-started/embedded-installation/#j-link","title":"J-Link","text":"<p>J-Link is the debug probe that we use to flash our firmware. Download two things from the following website:</p> <p>J-Link / J-Trace Downloads</p> <ol> <li>J-Link Software and Documentation Pack</li> <li>Ozone - The J-Link Debugger</li> <li>Optional (Systemview)</li> </ol> <p>Install the J-Link Software first as it contains drivers. Then install Ozone.</p> <p>Ozone is the flashed as well as a debugger for our firmware.</p> <ol> <li>Connect a J-Link to your computer.</li> <li>Select the right chip type (Board C is STM32F407IG</li> </ol> <p></p> <ol> <li>Next step, configure as follows. If you have a J-Link connected, it should show up in the emulator list.</li> </ol> <p></p> <ol> <li>Next step open up the elf binary file that we just compiled.</li> <li>For optional settings, use the default.</li> <li>When you open the project for the first time, you might be shown an error that FreeRTOS awareness is not enabled. To enable it, press apply the fix up. Next, modify this line (Project.SetOSPlugin (\"FreeRTOSPlugin\");) in the jdebug configuration file for your project\u2019s line by adding _CM4 to the original string. </li> </ol> <p></p> <ol> <li>Now you will be able to download the firmware by pressing the start button on the top left corner of the interface. After flashing is complete, the button will become a play button. Press play to start the program on board.</li> <li>Next you can open up the UserTasks.cpp file using file\u2192open. Add break points in a task\u2019s loop to start debugging.</li> <li>Most of the things we need are hidden in the view menu. I personally add stack and local data, global data, timeline, and watched data for debugging.</li> </ol>"},{"location":"getting-started/no-vnc/","title":"NoVNC-based Installation","text":"<p>Docker is a faster and more lightweight alternative comparing to normal virtual machines like VMWare and VirtualBox.</p>"},{"location":"getting-started/no-vnc/#install-docker","title":"Install Docker","text":"<p>Choosing an appropriate instruction based on your operating system:</p> <ul> <li>Windows Instructions</li> <li>Mac Instructions</li> <li>Ubuntu Instructions</li> </ul>"},{"location":"getting-started/no-vnc/#pull-and-run-docker-image","title":"Pull and Run Docker Image","text":"<p>Starting your command terminal, run:</p> <pre><code>docker run -p 6080:80 --security-opt seccomp=unconfined --shm-size=512m tiryoh/ros2-desktop-vnc:humble\n</code></pre> <p>ROS2-Desktop-VNC is a docker image that contains NoVNC and humble environment installed. This command launch the image at port 6080, so you can directly access it through the browser.</p> <p>To see more detailed, check README for the original image.</p>"},{"location":"getting-started/ros-installation/","title":"ROS-based Software Stack Installation","text":"<p>This document will run you through of process of setting up environment to run RoboRambler's ROS-based Software Stack.</p>"},{"location":"getting-started/ros-installation/#os-installation","title":"OS Installation","text":"<p>You will need a working Ubuntu 22.04 OS to run our control stack, simulation, and hardware interface.</p> <p>You have two options:</p> <ul> <li>Use native installation or Windows Subsystem for Linux (Recommended).</li> <li>Use a NoVNC server installation with Docker (Slow, Not Recommended).</li> </ul> <p>For native installation (on a brand-new computer or dual-booting with Windows), check this tutorial. For NoVNC server installation, checkout this separate document.</p> <p>Warning</p> <p>Dual-booting means you have to mess-around with your existing OS and data. THIS WILL BRING POTENTIAL HAZARDS TO YOU DATA AND IT CAN BE IN-RECOVERABLE. Always make you fully understand the potential risk dual-booting brings, and always back-up your drive and data. If you are not sure about any step inside dual-booting, ask someone with experience.</p>"},{"location":"getting-started/ros-installation/#ros2-installation","title":"ROS2 Installation","text":"<p>RoboRambler uses Robot Operating System, version Humble Hawksbill (humble for short). To install ROS2 humble, please check the official installation guide.</p> <p>Note that if you followed the NoVNC installation procedure above, you already have ROS2 installed.</p> <p>To check if ROS2 installation is successful, open command terminal and type:</p> <pre><code>ros2\nros2 run turtlesim turtlesim_node\n</code></pre> <p>You should be able to see the prompt printed first, then a blue window showing a turtle inside it, like shown below.</p> <p></p>"},{"location":"getting-started/ros-installation/#pulling-and-building-rambler-software","title":"Pulling and Building Rambler Software","text":"<p>Now you have ROS2 installed. It's time to pull and setup our software!</p>"},{"location":"getting-started/ros-installation/#tools-and-utilities","title":"Tools and Utilities","text":"<p>Let's first install all the compilation tools and utilities. In RoboRambler, we use Clang based on LLVM. Clang is a faster, modern, and feature-rich complication and development tool set. However, for potential compatibility issues, we will also install the basic GNU Complier Collection.</p> <pre><code># install gcc, most linux distro have it by default\nsudo apt-get install build-essential\n\n# install clang-18\nwget https://apt.llvm.org/llvm.sh\nchmod u+x llvm.sh\nsudo ./llvm.sh 18\n\n# test if installation is successful\ngcc --version\ng++ --version\nclang-18 --version\nclang-cpp-18 --version \n</code></pre> <p>If everything above run without error, then your complication tool installation is successful.</p> <p>Next, we are going to install Git. Git is a distributed version control system. Type in:</p> <pre><code>sudo apt-get install git\ngit --version\n</code></pre> <p>Next, we are going to install Visual Studio Code (VSCode for short), which is a great editor for C++ and ROS development. Check this site for detailed install instruction. Here we list a snippet of code for apt-based installation.</p> <pre><code>echo \"code code/add-microsoft-repo boolean true\" | sudo debconf-set-selections\nsudo apt-get install wget gpg\n\nwget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; packages.microsoft.gpg\nsudo install -D -o root -g root -m 644 packages.microsoft.gpg /etc/apt/keyrings/packages.microsoft.gpg\necho \"deb [arch=amd64,arm64,armhf signed-by=/etc/apt/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main\" |sudo tee /etc/apt/sources.list.d/vscode.list &gt; /dev/null\nrm -f packages.microsoft.gpg\n\nsudo apt install apt-transport-https\nsudo apt update\nsudo apt install code\n</code></pre> <p>After installation, go to a directory you want, and type in <code>code .</code>. You should see the VSCode GUI interface popping up. Setup you VSCode by installing the following plugins:</p> <ul> <li>Clangd (For C/C++ code insights, analysis, formatting and auto-completion)</li> <li>Python (For Python code insights &amp; auto-completion)</li> <li>ROS (For ROS development)</li> <li>Docker (Optional, for connecting to images)</li> </ul> <p>For all plugins, check to have Microsoft has the author.</p> <p>Note that if you are running NoVNC installation, it is also possible to directly attach to the running container (so you don't need to have VSCode installed inside NoVNC for code editing!) After installing the Docker plugin, just right click on the running image and choose \"Attach Visual Studio Code\".</p> <p>Finally, there's an optional bash configuration file you may want to have. ROS2 package complication always has a long line of arguments - which makes quick testing and prototyping really painful. By inserting these lines into the <code>~/.bash_aliases</code> file, you are able to use shortcuts.</p> <pre><code>export CC=clang-18\nexport CXX=clang++-18\nexport CMAKE_C_COMPILER=clang-18\nexport CMAKE_CXX_COMPILER=clang++-18\n# export CC=gcc\n# export CXX=g++\n# export CMAKE_C_COMPILER=gcc\n# export CMAKE_CXX_COMPILER=g++\n\nalias bd='colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_CXX_FLAGS=\"-w -O0 -g\"'\nbds() {\n  colcon build --symlink-install --cmake-args -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_CXX_FLAGS=\"-w -O0\" --packages-select=$1\n}\nalias bd-release='colcon build --symlink-install --cmake-args -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_BUILD_TYPE=RelWithDebInfo'\nalias rs=\"source install/setup.bash\"\nalias rclean=\"rm -r build/ log/ install/\"\nalias rosdepinstall=\"rosdep install --from-paths src --ignore-src -r -y\"\n\nalias bashconfigalias=\"code ~/.bash_aliases\"\nalias bashconfig=\"code ~/.bashrc\"\nalias bashconfigup=\"source ~/.bashrc\"\n</code></pre> <p>Note that you may change these aliases to anything you like. In the following document we are going to list full command, without any alias usage.</p>"},{"location":"getting-started/ros-installation/#git-ssh-key-setup","title":"Git SSH-Key Setup","text":"<p>To pull code from git, we need a way for our computer to be authenticated as being owned by you. The authentication method we usually use is Secure Shell Protocal (ssh for short). To set up ssh for GitHub, check out how to generate it, and how to add a new key to your GitHub Account.</p>"},{"location":"getting-started/ros-installation/#code-base-setup","title":"Code-base Setup","text":"<p>First, go to a directly you want the code base to be. Then, run the following commands:</p> <pre><code>mkdir -p rm_ws/src\ncd rm_ws/src\n</code></pre> <p>We just created a ROS2 workspace named <code>rm_ws</code>, and has entered the source code directly <code>src</code>.</p> <p>Note</p> <p>In ROS2 development, the so-called Workspace Directory or Project Directory always refer to level like <code>rm_ws</code> we just created. It is above the <code>src</code> directory. For any complication, Only do it when you are under the Workspace Directory, or you will find that you have a lot of miss-placed files.</p> <p>Inside <code>src</code>, we are going to pull all the code we have right now. Make sure you have access to our repositories, and you are under <code>src</code> directory, and type in the following command:</p> <pre><code># pull codes\ngit clone git@github.com:RM-GT/rm_common.git\ngit clone git@github.com:RM-GT/rm_controllers.git\ngit clone git@github.com:RM-GT/rm_hw.git\ngit clone git@github.com:RM-GT/rm_vision.git\ngit clone git@github.com:RM-GT/rm_descriptions.git\ngit clone git@github.com:RM-GT/rm_utils.git\n\n# pull external dependencies\nmkdir ext &amp;&amp; cd ext\ngit clone git@github.com:robomaster-oss/rmoss_core.git\ngit clone git@github.com:robomaster-oss/rmoss_interfaces.git\ngit clone git@github.com:RoverRobotics-forks/serial-ros2.git\ncd ../..\n\n# install parsing utility package for python\npip install Cheetah3\n</code></pre> <p>After successful pulling, return to the workspace directory. Then, we are going to use ROS2's package management tool <code>rosdep</code> to automatically fetch all the external dependencies.</p> <pre><code>rosdep init\nrosdep install --from-paths src --ignore-src -r -y\n</code></pre> <p>You should see <code>#All required rosdeps installed successfully</code> at the end.</p> <p>Finally we are able to build the code base!</p> <pre><code># setup compliers\nexport CC=clang-18\nexport CXX=clang++-18\nexport CMAKE_C_COMPILER=clang-18\nexport CMAKE_CXX_COMPILER=clang++-18\n\n# build the project!\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_CXX_FLAGS=\"-w -O0 -g\"\n</code></pre>"}]}